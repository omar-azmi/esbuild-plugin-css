var O=e=>{if(!(!e||e===""))return e.startsWith("npm:")?"npm":e.startsWith("jsr:")?"jsr":e.startsWith("data:")?"data":e.startsWith("http://")?"http":e.startsWith("https://")?"https":e.startsWith("file://")?"file":e.startsWith("./")||e.startsWith("../")?"relative":"local"},m=(e,o)=>{let c=o;if(typeof o=="string"){let a=O(o);switch(a){case"relative":case"npm":case"jsr":case"data":throw new Error(1?"the following base namespace is not supported: "+a:"");default:{c=m(o);break}}}let u=O(e);return u==="local"?new URL("file://"+e):u==="relative"?new URL(e,c):new URL(e)};var v="oazmi-css-plugin",p="oazmi-css",_=p+"-url-preserve",h=p+"-url-copy",w=/\.css$/,P=[/^data:/],L=[/\.gif$/,/\.jpeg$/,/\.png$/,/\.svg$/,/\.ttf$/];var b=(e={})=>{let{cache:o=new Map,filter:c=w,preserveUrl:u=P,copyUrl:y=L}=e,a=[];return{name:v,setup:l=>{let U=n=>{0&&console.log("[css-plugin] resolve args:",n);let{path:t,importer:s,kind:i}=n,r=m(t,i==="entry-point"?void 0:s).toString();return 0&&console.log("[css-plugin] css path resolved to:",r),{path:r,namespace:p,pluginData:{kind:i,importer:s,originalPath:t}}};u.forEach(n=>l.onResolve({filter:n,namespace:p},async t=>{let{path:s,importer:i,kind:r}=t;return 1&&console.assert(r==="import-rule"||r==="url-token","the importer of the following path is not a css file (not a css import-rule)",`
	path:`,s,`
importer:`,i,`
kind:`,r),0&&console.log("[css-plugin-url-preserve] preserve url import:",s),{path:s,namespace:_,external:!0}})),y.forEach(n=>l.onResolve({filter:n,namespace:p},async t=>{let{path:s,importer:i,kind:r}=t;return 1&&console.assert(r==="import-rule"||r==="url-token","the importer of the following path is not a css file (not a css import-rule)",`
	path:`,s,`
importer:`,i,`
kind:`,r),0&&console.log("[css-plugin-url-copy] copy imported file - resolved path:",s,`
	with importer:`,i),{path:s,namespace:h,pluginData:{importer:i}}})),l.onLoad({filter:/.*/,namespace:h},async n=>{let t=m(n.path,n.pluginData.importer),s=new Uint8Array(await(await fetch(t)).arrayBuffer());return 0&&console.log("[css-plugin-url-copy] copy imported file - loaded path:",t.toString(),`
	with size:`,s.length),{loader:"copy",contents:s}}),l.onResolve({filter:c},U),l.onLoad({filter:/.*/,namespace:p},async n=>{0&&console.log("[css-plugin] load args",n);let{kind:t,importer:s,originalPath:i}=n.pluginData,{path:r}=n,f=o.get(r);if(0&&f&&console.log("[css-plugin] using cached result"),e.mode==="inject"&&t==="import-statement"||t==="dynamic-import"){let d=f;if(d===void 0){let g=(await l.esbuild.build({...l.initialOptions,entryPoints:[r],plugins:[b({mode:"bundle",filter:c,cache:o})],outbase:"",bundle:!0,splitting:!1,write:!1})).outputFiles,x=g.findIndex(N=>c.test(N.path));1&&console.assert(x>=0,"failed to discover the separately bundled css file."),d=g.splice(x,1).pop().text,o.set(r,d),a.push(...g)}return{loader:"js",contents:`
const style_dom = document.createElement("style")
style_dom.textContent = String.raw\``+d.replaceAll("`","`")+"`\ndocument.head.append(style_dom)"}}let R=f??await(await fetch(new URL(r))).text();return o.set(r,R),{loader:"css",contents:R}}),l.onEnd(async n=>{a.length>0&&(0&&console.log(`additional files that were supposed to get copied:
`,a.map(t=>{let{path:s,contents:i}=t;return{path:s,size:i.length}})),l.initialOptions.write!==!1?Promise.all(a.map(t=>(0&&console.log("writing to:",t.path),Deno.writeFile(t.path,t.contents)))):(n.outputFiles??=[],n.outputFiles.push(...a)))})}}};export{b as cssPlugin};
